<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CSS1</title>
    <!--  CSS 적용하기  -->
    <!--
        Link style 
        <link rel="stylesheet" href="../css_folder/style01.css" />
     -->
    <!-- 
        Embedding style
        head에 
        <style></style> 사이에 css를 포함시키는 것
      -->
    <!-- 
        Inline style
        css를 적용할 내요엥 직접 style을 지정해 주는 것
        <p style="color: black">Hello World</p>
     -->
  </head>
  <body>
    <!-- 
      선택자{
        스타일 속성 : 속성 값
      }
        p, div { color: blue; font-size: 10px; }
        ,로 셀렉터를 복수개 지정할 수 있다
        속성 구별은 ;로 한다
        id는 #id 로 셀렉터를 작성한다
        class는 .class 로 셀렉터를 작성한다
        <p class="center  color  size"?</p>등으로 class는 공백을 이용해
                 한번에 여러개 줄 수 있다
        태그.클래스로 특정 태그 내의 클래스에 스타일을 지정해 줄 수 있다
            p.copy : p태그에 있는 copy class만 스타일을 지정한다
        어트리뷰트는 셀렉터[어트리뷰트]형식으로 지정해 줄 수 있다
            a[href] a요소 중 모든 href 요소에 적용한다
            a[href="값"] 으로 특정 값만 지정할 수 있다
            (~= |= ^= $= *= 등으로 값들을 조절할 수 있다)
        후손셀렉터는 공백으로 구분한다 (후손은 모든 하위 요소에 지정)
            셀렉터 A 셀렉터 B   div p{ color : blue;}
            div 요소의 후손 중 p에 스타일을 지정한다
        자식셀렉터는 > 로 구분한다 (자식은 바로 하위만 지정)
            셀렉터 A > 셀렉터 B div > p {color : black;}
        전체셀렉터는 *로 지정한다(모든 값에 스타일을 적용한다)
        형제셀렉터는 +, ~로 구분한다(뒤에 나오는 값들에 스타일을 지정한다)
        가상셀렉터는 :로 구분하며 css에서 지정된 이름이 이미 있기 때문에
                    임의의 이름은 사용할 수 없다(:hover 등)
        가상요소셀렉터는 ::로 구분하며 특정 부분에 스타일을 적용할 때 사용한다
                    css에서 지정된 이름이 이미 존재한다\
                    ::before / ::after
                          .menu li::before { content: "👍";}
                          .menu li::after { content: " :after"; color: red;}

        선택자 우선순위
        1. !important 키워드는 우선순위를 무시하고 해당 스타일을 강제로 적용
        2. 인라인               - 1000
        3. 아이디 선택자(#)     - 100
        4. 클래스 선택자(.)     - 10
        5. 태그 선택자          - 1

      스타일을 적용하는 방법
      1. 인라인 방식(직접 태그안에 style 속성에 접근)
      2. <head>태그 안에 <style>태그 내에서 선택자로 접근
      3. 외부파일로부터 선택자로 접근

      Box구성
      Content padding border margin으로 구성된다
      border를 경계선으로 내부에서 padding이 content를 둘러싸고 margin이 border를 둘러싼다

      전체 너비
        width + left padding + right padding + left border + right border + left margin + right margin
      전체 높이
        height + top padding + bottom padding + top border + bottom border + top margin + bottom margin
      margin, padding 은 (순서) top right bottom left 로 구분할 수 있다
      margin, padding 만 작성하면 한번에 4곳을 전부 조정할 수 있다
      3개만 작성하면 top right+left bottom 으로 구별하며
      2개만 작성하면 top+bottom right+left로 구별한다
      
      border는 top right bottom left 각 구역에 스타일, 너비 색상을 조정할 수 있다
      border-radius로 각 모서리를 둥글게 표현할 수 있다
      4개면 top(left right) bottom(right left) 순서이고
      2개면 top(left)bottom(right) / top(right)bottom(left)로 나누어진다
      border-sizing은 width, height의 대상 영역을 조정할 수 있다
      content-box : width, height가 content 영역의 크기이다
      border-box : width, height가 border 영역의 크기이다(padding border도 포함한다)

      font
        font-size : 텍스트 크기
        font-weight : 글자의 두께 100~900,
                    bold(700), bolder, lighter, nomal(400)
        font-family : 글꼴 지정 (컴퓨터에 해당 폰트가 설치되어 있어야한다)
        font-style : 문자 스타일(nomal, italic)
        color : 글꼴의 색상 지정
        text-align : 텍스트의 수평정렬을 정의(center right left justify)
        text-decoration : 텍스트의 줄 표시 / 제거(overline underline line-through)
        text-transform : 대소문자 변환(capitalize upper lowercase)
        text-shadow : 텍스트 그림자 효과

        block/inline/inline-block/none
        -block 레벨요소
        항상 새로운 라인에서 시작
        화면 크기 전체의 가로폭(100%)을 차지
        width height margin padding 을 지정할 수 있다 (미지정시 100% auto)
        내부에 inline요소를 포함할 수 있다
        ex) div, table, h1~6, caption, header, section, p, ul, ol
        -inline 레벨요소
        줄을 바꾸지 않고 다른 요소와 함께 한 행에 위치한다
        content의 너비만큼 가로폭을 차지한다
        width등을 지정할 수 없다
        inline 내에 block 레벨 요소를 포함할 수 없다
        ex) a, img, br, span, input, textarea, label, button ..
        -inline-block 레벨 요소
        block와 inline의 특성을 모두 가진다
        한 줄에 표현가능하면서 크기를 조정할 수 있다
        미지정시 content의 너비만큼 가로폭을 차지한다
        ex) img, input, button ...


    float
        레이아웃을 구성할 때 블록 레벨요소를 정렬하기 위하여 사용한다
        (right left none)
        좌측 우측 정렬만 가능하기 때문에 중앙 가로 정렬은 margin을 이용해야한다
        width 프로퍼티를 선언하지 않은 block 레벨 요소에 float 프로퍼티가 선언되면
        width가 inline 요소와 같이 content에 맞게 최소화되고 다음 요소 위에 떠 있게된다
        하지만 설정하지 않은 요소(1)가 특정 요소(2) 위에 떠 있어도 특정요소(2)의 크기는 100%에서
        감소하지 않기 때문에 콘텐츠가 겹칠 위험이 존재한다
        이럴 경우 overflow-hidden을 선언해주어야한다(특정요소(2)에)
        float이 선언된 자식요소를 포함하는 부모 요소의 높이가 제대로 표현되지 않을 때에도
        부모요소에 overflow-hidden을 선언해주어야한다
        또는 display: inline-block를 선언해주는 것인데 이것을 연속으로 사용할 경우
        요소 사이에 4px의 공백이 생기기 때문에 부모요소에 font-size:0를 선언해주어야한다
        또 float 속성이 적용되면 다음 요소 또한 자동으로  float이 정용되는데 이때 
        clear를 해줘야 적용되지않는다         
        clear: both;(left right both none)

    수평정렬
        overflow: scroll;   (visiblem hidden scroll )
        inline/inline-block의 경우
        부모요소에 text-align : center를 이용하여 정렬한다
        block요소의 경우
        width를 지정하고 margin-right/left를 auto로 지정하여 정렬한다(margin: 20px auto)
        복수의 block의 경우
        기본적으로 수직정렬이 되고 수평정렬을 하려면
        정렬할 block 요소를 inline-block요소로 변경한 뒤 부모요소에 text-align:center를 적용한 뒤
        너비를 지정해 주어야한다 (display : inline-block; width : 20px;)


    시멘틱 태그
        header : 헤더
        aside : 사이드의 공간
        section : 본문의 공간 또는 큰 틀을 의미한다 내부에 header/ aside 등 전부 들어갈 수 있다
        article or main : 주내용이 들어가는 공간
        footer : 맨 아래 위치하는 공간
        이들 내부에서 div등으로 공간을 나누어 표현한다
     -->
  </body>
</html>
